# [Silver I] 숨바꼭질 - 1697 

[문제 링크](https://www.acmicpc.net/problem/1697) 

풀이 참고 O

# 🪄 문제 탐색하기

처음에 그리디의 가능성을 두고 생각해봤으나 최선의 선택이 무엇인지 알기 어려웠다.

(예시를 보면 단순히 처음에 2x를 반복하는 것이 최선의 선택은 아니다.)

구현 문제이지 않을까도 싶었으나 BFS문제임을 보고, 이걸 어떻게 BFS로 풀지?라는 생각이 들었다.

수직선 상의 모든 정수 좌표로 이동할 수 있으니 일직선 그래프를 생각해야하나? 그래프를 떠올리기 어려웠다.

.
.
.

x위치에서 1초의 시간이 걸려 이동하는 방법에는 x-1, x+1, 2x 의 세 가지가 있다.

따라서 모든 노드의 차수가 3인 트리를 생각해볼 수 있다. (루트 노드는 시작 위치인 n으로 설정)

루트에서 시작해 트리의 경로를 따라가면 각 초마다 움직이는 위치에 따라 경로가 정해지는 것으로 볼 수 있다.

동생의 위치 k인 노드는 트리상에서 여러 개가 존재할 수 있으나, 트리에서 같은 레벨의 노드들은 같은 시간을 가지므로 최소 시간을 구하려면 

이 중 최소 레벨인 것을 찾으면 된다! 따라서 너비우선탐색으로 문제를 풀 수 있는 것이다.

![image](https://github.com/user-attachments/assets/16f608d3-9565-4a5d-9a69-7981e55eaf3d)



# 🪄 코드 설계하기

- bfs 코드와 거의 동일하되, 다음 가지만 수정한다.

1.이 문제에서 visited는 방문 여부가 아니라 i인덱스 위치까지 오는데 걸린 시간이 기록된다.

2.위치 범위는 10만까지이므로 visited 배열의 크기는 10만+1로 설정한다.

3.v의 인접 노드는 v-1, v+1, 2*v이므로 이들이 10만 이하이고 아직 미방문 상태라면 큐에 삽입한다,. visited값은 부모인 v의 visited[v]+1


# 🪄 새로 알게 된 사실

간선의 비용이 동일한 상황에서 (또는 간선의 가중치가 없을 때) BFS로 최단거리/최소시간 문제를 해결할 수 있다.

그래프가 명시적으로 나타나있지 않더라도 그래프를  이용한 풀이를 떠올려보자.

<br>
<br>
<br>
<br>





### 성능 요약

메모리: 38148 KB, 시간: 92 ms

### 분류

너비 우선 탐색, 그래프 이론, 그래프 탐색

### 제출 일자

2025년 3월 11일 23:58:34

### 문제 설명

<p>수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.</p>

<p>수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.</p>

### 출력 

 <p>수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.</p>

